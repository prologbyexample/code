#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\use_default_options true
\begin_modules
logicalmkup
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "berasans" "default"
\font_typewriter "courier" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype true
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize 10
\spacing single
\use_hyperref false
\papersize custom
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 6in
\paperheight 9in
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip 10pt
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Queries That Don't Finish
\end_layout

\begin_layout Standard
A milestone on the journey of learning prolog is writing queries that don't
 complete.
 In some cases, this is the correct behaviour, but in others, it is undesirable.
 
\end_layout

\begin_layout Standard
We'll take a first look at this phenomenon using the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
reversed/2
\end_layout

\end_inset

 property we developed earlier.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Prolog,basicstyle={\scriptsize\ttfamily},frame=lines,aboveskip={\bigskipamount}"
inline false
status open

\begin_layout Plain Layout

% Example 11 - Bidirectional Termination
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% recursive definition
\end_layout

\begin_layout Plain Layout

step([], L2, L2).
 
\end_layout

\begin_layout Plain Layout

step([H1|T1], X, L2) :- step(T1, X, [H1|L2]).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% convenience property around step/3
\end_layout

\begin_layout Plain Layout

reversed(X, Y) :- step(X, Y, []).
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% updated to terminate when first list is a variable
\end_layout

\begin_layout Plain Layout

reversed2(X, Y) :- same_length(X,Y), step(X, Y, []).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
reversed(X,Y)
\end_layout

\end_inset

 property is true if the list 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Y
\end_layout

\end_inset

 is the list 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X
\end_layout

\end_inset

 but in reverse order.
 We previously asked 
\begin_inset Quotes eld
\end_inset

which 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Y
\end_layout

\end_inset

 is the reverse of the list 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
[1,2,3]
\end_layout

\end_inset

?
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Prolog,basicstyle={\scriptsize\ttfamily},frame=lines,aboveskip={\bigskipamount}"
inline false
status open

\begin_layout Plain Layout

?-  reversed([1, 2, 3],Y).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Y = [3, 2, 1]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Prolog tells us 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Y=[3,2,1]
\end_layout

\end_inset

 is a valid answer.
 In fact, prolog tells us it is the only answer because it doesn't ask to
 continue searching for more possible answers.
 The query 
\series bold
terminates
\series default
 after the solution is found.
\end_layout

\begin_layout Subsubsection*
Termination
\end_layout

\begin_layout Standard
On several occasions we've pointedly commented that a prolog definition
 was written well enough for a question to be asked in both directions.
 For example, our earlier definition of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ancestor/2
\end_layout

\end_inset

 allows us to ask 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ancestor(X, sally)
\end_layout

\end_inset

, as well as 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ancestor(sally, Y)
\end_layout

\end_inset

.
 That is, 
\begin_inset Quotes eld
\end_inset

who are the ancestors of Sally?
\begin_inset Quotes erd
\end_inset

, as well as 
\begin_inset Quotes eld
\end_inset

who is Sally an ancestor of?
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Prolog,basicstyle={\scriptsize\ttfamily},frame=lines,aboveskip={\bigskipamount}"
inline false
status open

\begin_layout Plain Layout

?- ancestor(X, sally).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

X = martha
\end_layout

\begin_layout Plain Layout

X = deirdre
\end_layout

\begin_layout Plain Layout

false
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

?- ancestor(sally, X).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

X = jane
\end_layout

\begin_layout Plain Layout

false
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Prolog reports 
\series bold
false
\series default
 when there are no more answers to be found.
 In both cases, the query 
\series bold
terminates
\series default
 after all the answers have been found.
 
\end_layout

\begin_layout Subsubsection*
Non-Termination
\end_layout

\begin_layout Standard
Back to our 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
reversed/2
\end_layout

\end_inset

 property.
 Let's query in the other direction by asking 
\begin_inset Quotes eld
\end_inset

which 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X
\end_layout

\end_inset

, when reversed, is the list 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
[1,2,3]
\end_layout

\end_inset

?
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Prolog,basicstyle={\scriptsize\ttfamily},frame=lines,aboveskip={\bigskipamount}"
inline false
status open

\begin_layout Plain Layout

?-  reversed(X,[1, 2, 3]).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

X = [3, 2, 1]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

...
  non-termination ...
\end_layout

\begin_layout Plain Layout

** Execution aborted **
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Prolog correctly finds 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X=[3,2,1]
\end_layout

\end_inset

 as a valid answer.
 It then asks to find more answers.
 Given the go-ahead, prolog ends up searching along a never-ending path,
 which will crash the entire program if left long enough.
 We have to manually intervene and cancel the query.
\end_layout

\begin_layout Standard
This is our first example of 
\series bold
non-termination
\series default
.
 Non-termination can be problematic because we can't determine whether or
 not there are more solutions yet to be found.
 In this particularly simple example, we know there can't be any other lists
 whose reverse is 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
[1,2,3]
\end_layout

\end_inset

, but in more sophisticated scenarios we can't be so certain.
\end_layout

\begin_layout Subsubsection*
Non-Termination Isn't Always Wrong
\end_layout

\begin_layout Standard
In some cases, non-termination is the right behaviour.
 For example, we might define a property of lists such that every item in
 a list is 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
cat
\end_layout

\end_inset

.
 That definition is satisfied by an infinite set of lists, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
[cat]
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
[cat, cat]
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
[cat, cat, cat]
\end_layout

\end_inset

, and so on.
 It would be logically incorrect for a query asking 
\begin_inset Quotes eld
\end_inset

which lists satisfy this definition
\begin_inset Quotes erd
\end_inset

 to terminate.
\end_layout

\begin_layout Standard
In other cases, non-termination only happens when queries are made in one
 direction, as in our example 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
reversed(X,[1,2,3])
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
This kind of non-termination doesn't always have to be fixed.
 It's not unusual to find, even official, prolog properties intended to
 be used only in one direction.
 In such cases, the documentation makes clear which paramaters are expected
 to be grounded and which can be left as variables.
 Because 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
reversed(X,Y)
\end_layout

\end_inset

 is symmetric in 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Y
\end_layout

\end_inset

, it is quite reasonable, and no real inconvenience, to require the first
 parameter be grounded.
 
\end_layout

\begin_layout Subsubsection*
Fixing Non-Termination
\end_layout

\begin_layout Standard
If we do decide to fix non-termination, it is better to apply an additional
 logical constraint, than try to fix it with a procedural hack.
 This way, the property retains its logical meaning.
 This isn't always easy, especially when the non-termination is a direct
 result of prolog's procedural nature.
 
\end_layout

\begin_layout Standard
Let's work out why the query 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
reversed(X,[1,2,3])
\end_layout

\end_inset

 fails to terminate.
 To do this we need to remind ourselves of how 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
reversed/2
\end_layout

\end_inset

 works.
 
\end_layout

\begin_layout Standard
Initially, nothing is known about 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X
\end_layout

\end_inset

, and the accumulator starts as an empty list in 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
step(X,Y,[])
\end_layout

\end_inset

.
 With each application of the continuation rule, the accumulator is extended
 from its head.
 This extends the length of possible solution for 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X
\end_layout

\end_inset

.
 When the length of the accumulator reaches the same length as the provided
 list 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
[1,2,3]
\end_layout

\end_inset

, the termination rule lets prolog report 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X=[3,2,1]
\end_layout

\end_inset

 as an answer.
 But prolog doesn't stop there.
 It backtracks and keeps applying the continuation rule to extend the accumulato
r, in effect, trying to find solutions that are longer in length than 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
[1,2,3]
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
We can prevent this undesirable backtracking by adding a logical constraint
 which asserts that a list and its reverse have the same length.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Prolog,basicstyle={\scriptsize\ttfamily},frame=lines,aboveskip={\bigskipamount}"
inline false
status open

\begin_layout Plain Layout

% updated to terminate when first list is a variable
\end_layout

\begin_layout Plain Layout

reversed2(X, Y) :- same_length(X,Y), step(X, Y, []).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This new 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
reversed2/2
\end_layout

\end_inset

 property uses 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
same_length/2
\end_layout

\end_inset

 provided by swi-prolog to assert that 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Y
\end_layout

\end_inset

 have the same length.
 Note that it needs to be placed before the recursive 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
step/3
\end_layout

\end_inset

 to ensure that 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X
\end_layout

\end_inset

 is created with a fixed length, albeit with currently unknown values.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Prolog,basicstyle={\scriptsize\ttfamily},frame=lines,aboveskip={\bigskipamount}"
inline false
status open

\begin_layout Plain Layout

?- reversed2(X,[1, 2, 3]).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

X = [3, 2, 1]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This time the query returns the single correct answer and terminates immediately.
\end_layout

\begin_layout Standard
It may seem obvious that 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Y
\end_layout

\end_inset

 are of the same length, but it wasn't obvious that it needed asserting.
 Lots of thinking to make a small change is the norm when working in declarative
 and logic languages like prolog.
\end_layout

\begin_layout Subsubsection*
samelength/2
\end_layout

\begin_layout Standard
If 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
same_length/2
\end_layout

\end_inset

 isn't provided by your prolog, you can easily create your own, as follows.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Prolog,basicstyle={\scriptsize\ttfamily},frame=lines,aboveskip={\bigskipamount}"
inline false
status open

\begin_layout Plain Layout

% samelength/2 if same_length/2 isn't provided
\end_layout

\begin_layout Plain Layout

samelength([], []).
 
\end_layout

\begin_layout Plain Layout

samelength([_H1|T1], [_H2|T2]) :- samelength(T1, T2).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It's a good idea to check you can read and understand this particularly
 simple recursive definition.
\end_layout

\begin_layout Subsubsection*
Testing For Termination
\end_layout

\begin_layout Standard
Imagine we want to test whether a query, let's call it 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
q
\end_layout

\end_inset

, terminates.
 
\end_layout

\begin_layout Standard
We could run the query and manually prompt prolog to keep searching for
 more solutions until it tells us there are no more to be found.
 Ten prompts would be inconvenient.
 A hundred prompts would be impractical.
 Some queries might require millions of prompts.
\end_layout

\begin_layout Standard
Is there a way to exhaust the search for all possible solutions without
 manual prompting? Have a look at the following.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Prolog,basicstyle={\scriptsize\ttfamily},frame=lines,aboveskip={\bigskipamount}"
inline false
status open

\begin_layout Plain Layout

?- q, fail.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
fail
\end_layout

\end_inset

 is a goal that always fails.
 We could have used something like 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
1=2
\end_layout

\end_inset

, which also always fails, but 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
fails
\end_layout

\end_inset

 is easier to read and understand.
 
\end_layout

\begin_layout Standard
Prolog works left to right, so it will first try to find a solution that
 satisfies the goal 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
q
\end_layout

\end_inset

.
 Having done this, it will encounter 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
fail
\end_layout

\end_inset

, which causes the query to fail, as if the solution found for the first
 part 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
q
\end_layout

\end_inset

 did not satisfy the second part.
 This causes prolog to backtrack and try to find another solution for 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
q
\end_layout

\end_inset

.
 That second solution, if there is one, will be seen as unsatisfactory too
 because prolog will encounter 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
fail
\end_layout

\end_inset

 again.
 This will repeat for all possible solutions to 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
q
\end_layout

\end_inset

.
 The test 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
q,fail
\end_layout

\end_inset

 will terminate once all the possible solutions for 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
q
\end_layout

\end_inset

 have been found.
\end_layout

\begin_layout Standard
So, if the test 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
q,fail
\end_layout

\end_inset

 terminates, we know the query 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
q
\end_layout

\end_inset

 also terminates.
 It is possible that 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
q
\end_layout

\end_inset

 takes a long time to exhaust, and so the test appears not to terminate.
 This is why we can't say 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
q
\end_layout

\end_inset

 doesn't terminate if the test is not observed to terminate.
\end_layout

\begin_layout Standard
Let's test if 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
reversed2(X,[1,2,3])
\end_layout

\end_inset

 terminates.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Prolog,basicstyle={\scriptsize\ttfamily},frame=lines,aboveskip={\bigskipamount}"
inline false
status open

\begin_layout Plain Layout

?- reversed2(X,[1,2,3]), fail.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

false
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The test terminates, confirming 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
reversed2(X,[1,2,3])
\end_layout

\end_inset

 does terminate.
 Prolog's reply 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
false
\end_layout

\end_inset

 is not wrong, it is what we expect from a test that fails every solution
 to the goal being tested.
\end_layout

\begin_layout Subsubsection*
Key Points
\end_layout

\begin_layout Itemize
Non-termination happens when prolog follows an unending search path trying
 to resolve a query.
\end_layout

\begin_layout Itemize
Not all non-termination is wrong.
 Some queries should, logically, have an infinite number of answers,
\end_layout

\begin_layout Itemize
Some non-termination depends on which query parameters are ungrounded variables.
 It is not uncommon for prolog properties to require specific parameters
 to be grounded.
\end_layout

\begin_layout Itemize
Wherever possible, fixing undesirable non-termination should be done by
 adding logical constraints to a definition.
\end_layout

\begin_layout Itemize
We can test whether a query 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
q
\end_layout

\end_inset

 does terminate.
 If 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
q,fail
\end_layout

\end_inset

 terminates, then we can say 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
q
\end_layout

\end_inset

 terminates.
 
\end_layout

\begin_layout Itemize
If the test 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
q,fail
\end_layout

\end_inset

 doesn't appear to terminate, we can't conlude definitively that 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
q
\end_layout

\end_inset

 doesn't terminate.
\end_layout

\end_body
\end_document
