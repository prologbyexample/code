#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\use_default_options true
\begin_modules
logicalmkup
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "berasans" "default"
\font_typewriter "courier" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype true
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize 10
\spacing single
\use_hyperref false
\papersize custom
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 6in
\paperheight 9in
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip 10pt
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
The Cut
\end_layout

\begin_layout Standard
There will come a point when we hear about the so-called 
\series bold
cut
\series default
.
 It is spoken of with words of caution, as if it were a forbidden power
 capable of great good and great evil.
\end_layout

\begin_layout Standard
We'll take our time learning about it, starting with a minimal example.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Prolog,basicstyle={\scriptsize\ttfamily},frame=lines,aboveskip={\bigskipamount}"
inline false
status open

\begin_layout Plain Layout

% Example 12 - The Cut
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% who is happy
\end_layout

\begin_layout Plain Layout

happy(john).
 
\end_layout

\begin_layout Plain Layout

happy(jane) :- !.
 
\end_layout

\begin_layout Plain Layout

happy(jill).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Setting aside the exclamation mark 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
!
\end_layout

\end_inset

 for now, this short prolog program creates three facts.
 John is happy, Jane is happy, and Jill is happy.
\end_layout

\begin_layout Subsubsection*
Who Is Happy?
\end_layout

\begin_layout Standard
Let's start by running some very basic queries to establish a firm and familiar
 foundation.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Prolog,basicstyle={\scriptsize\ttfamily},frame=lines,aboveskip={\bigskipamount}"
inline false
status open

\begin_layout Plain Layout

?- happy(john).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

?- happy(jane).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

?- happy(jill).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

true
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Everything is familiar, and as expected.
 The queries confirm John, Jane and Jill are happy.
\end_layout

\begin_layout Standard
Let's now ask 
\begin_inset Quotes eld
\end_inset

who is happy?
\begin_inset Quotes erd
\end_inset

 in the usual way using a variable.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Prolog,basicstyle={\scriptsize\ttfamily},frame=lines,aboveskip={\bigskipamount}"
inline false
status open

\begin_layout Plain Layout

?- happy(X).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

X = john
\end_layout

\begin_layout Plain Layout

X = jane
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This isn't quite what we expected.
 Prolog didn't provide 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X=jill
\end_layout

\end_inset

 as an answer.
 It is as if prolog stopped trying to find additional answers after that
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
!
\end_layout

\end_inset

 symbol.
\end_layout

\begin_layout Subsubsection*
The Cut
\end_layout

\begin_layout Standard
The excalamation mark 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
!
\end_layout

\end_inset

 is called a 
\series bold
cut
\series default
.
 The following solution search tree illustrates the effect of the cut on
 our query.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename diagrams/12_the_cut.pdf
	scale 50

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let's break it down.
 To find solutions to the query 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
happy(X)
\end_layout

\end_inset

, prolog tries unifying with rules in its database.
 
\end_layout

\begin_layout Standard
The first rule is 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
happy(john)
\end_layout

\end_inset

 and this results in the first solution 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X=john
\end_layout

\end_inset

.
 Prolog backtracks to the point where 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X
\end_layout

\end_inset

 is again unbound and tries to find another solution.
 
\end_layout

\begin_layout Standard
This time prolog finds the rule 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
happy(jane):-!
\end_layout

\end_inset

, and successfully unifies with its head.
 Before it can settle on 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X=jane
\end_layout

\end_inset

 as the next solution, the body of the rule needs to be true.
 That body is simply the cut 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
!
\end_layout

\end_inset

, which always succeeds, but also has the side-effect of telling prolog
 to stop any further backtracking.
 This stops prolog searching for more solutions.
 This is why prolog doesn't attempt to unify with the rule 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
happy(jill)
\end_layout

\end_inset

, and is why 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X=jill
\end_layout

\end_inset

 is not returned as a third solution.
\end_layout

\begin_layout Standard
So the effect of a cut is to stop prolog backtracking over it.
 It causes prolog to commit to whatever parts of a solution it has found
 up to the point the cut appears in a rule.
 It is called the cut because it cuts off part of the solution search tree,
 as illustrated above.
\end_layout

\begin_layout Standard
Looking back to our direct querying of facts, prolog did confirm that 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
happy(jill)
\end_layout

\end_inset

 is 
\series bold
true
\series default
.
 This tells us the cut only takes effect when prolog is searching for solutions
 using the backtracking mechanism.
\end_layout

\begin_layout Subsubsection*
Cut With Caution
\end_layout

\begin_layout Standard
Even with this small example, we can see the cut introduces a logical 
\series bold
inconsistency
\series default
.
 
\end_layout

\begin_layout Standard
One the one hand, asking 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
happy(jill)
\end_layout

\end_inset

 tells us Jill is happy, but on the other hand, asking 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
happy(X)
\end_layout

\end_inset

 excludes Jill from the list of happy people.
 
\end_layout

\begin_layout Standard
This breakdown of logical consistency is not good, and can be dangerous.
 The larger and more complex our programs become, the harder it is to find
 such logical inconsistencies.
 Even worse, we may not even be aware inconsistencies are happening.
\end_layout

\begin_layout Standard
It is natural to ask why such something as dangerous as the cut even exists
 at all.
 We'll see later how the cut can be useful, if used carefully.
\end_layout

\begin_layout Subsubsection*
Key Points
\end_layout

\begin_layout Itemize
The exclamation mark symbol 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
!
\end_layout

\end_inset

 is called a cut.
\end_layout

\begin_layout Itemize
A cut is only used in the body of a rule, never the head.
\end_layout

\begin_layout Itemize
A cut always succeeds but stops prolog from backtracking over it, preventing
 prolog from searching for more possible solutions to a query.
\end_layout

\begin_layout Itemize
The cut only effects backtracking, which is why a specific query can return
 a solution, whereas a more general query using a variable might not.
\end_layout

\begin_layout Itemize
The cut can cause different, but logically consistent, queries to give logically
 inconsistent solutions.
\end_layout

\end_body
\end_document
